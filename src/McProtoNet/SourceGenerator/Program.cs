using SourceGenerator.ProtoDefTypes;
using System.Text;


internal class Program
{
	private static async Task Main(string[] args)
	{


		using var sr = new StreamReader("protocol.json");


		string json = sr.ReadToEnd();


		Protocol proto = new ProtodefParser(json).Parse();


		var toServerPackets = (proto.Namespaces["play"].Types["toClient"] as Namespace);

		string outDir = @"C:\Users\Title\source\repos\Minecraft-Holy-Client\src\McProtoNet\TestGenerator\ServerPackets";

		List<NetClass> netClasses = new();

		foreach (var (key, val) in toServerPackets.Types)
		{
			ProtodefContainer packet = (ProtodefContainer)val;

			if (key.StartsWith("packet_"))
			{
				var onlyNumbers = packet.All(x => (x.Type.IsPrimitive() || x.Type.IsArray() || x.Type.IsBuffer()) && !string.IsNullOrEmpty(x.Name));

				if (onlyNumbers)
				{
					NetClass netClass = new();

					string packetName = key.Replace("packet_", "");
					packetName = Helpers.ToPascalCase(packetName);

					packetName = $"Server{packetName}Packet";

					netClass.Name = packetName;
					bool ok = true;
					foreach (var field in packet)
					{
						string filedName = Helpers.ToPascalCase(field.Name);

						string type = "";
						if (field.Type.IsPrimitive())
						{
							type = field.Type.ToString();


							if (type == "varint")
								type = "int";
							if (type == "varlong")
								type = "long";
						}
						else if (field.Type.IsArray())
						{
							ProtodefArray array = field.Type as ProtodefArray;
							if (array.CountType.IsPrimitive() && array.Type.IsPrimitive())
							{
								string arrType = array.Type.ToString();

								if (arrType == "varint")
									arrType = "int";
								if (arrType == "varlong")
									arrType = "long";

								type = $"{arrType}[]";
							}
							else
							{
								ok = false;
								break;
							}
						}
						else if (field.Type.IsBuffer())
						{
							type = "byte[]";
						}



						netClass.Fields[filedName] = type;
					}


					if (ok)
						netClasses.Add(netClass);
				}
			}
		}

		var tasks = new List<Task>();
		foreach (var @class in netClasses)
		{
			string path = Path.Combine(outDir, $"{@class.Name}.cs");

			tasks.Add(File.WriteAllTextAsync(path, @class.Generate()));
		}

		await Task.WhenAll(tasks);

		//Console.ReadLine();
	}


}

public sealed class NetClass
{
	public Dictionary<string, string> Fields { get; set; } = new();
	public string Name { get; set; }
	public string Generate()
	{
		StringBuilder builder = new StringBuilder();

		builder.AppendLine("//AutoGenerated")
			.AppendLine()
			.AppendLine("namespace McProtoNet.Packets;")
			.AppendLine()
			.AppendLine($"public sealed class {Name}")
			.AppendLine("{");
		GenerateFileds(builder);

		builder.AppendLine("}");

		return builder.ToString();


	}
	private void GenerateFileds(StringBuilder builder)
	{
		foreach (var (name, type) in Fields)
		{


			string prop = $"public {type} {name} {{ get; set; }}";
			builder.AppendLine("\t" + prop);
		}
	}
}
public static class Extensions
{



	public static string GenerateReadMethod(this ProtodefType type, string propName)
	{
		if (type.IsPrimitive())
		{



		}
		throw new NotImplementedException();
	}

	public static bool IsPrimitive(this ProtodefType type)
	{
		if (type is ProtodefNumericType)
			return true;
		if (type is ProtodefVarInt)
			return true;

		if (type is ProtodefVarLong)
			return true;

		if (type is ProtodefCustomType customType)
		{
			return customType.Name == "bool" || customType.Name == "string";
		}

		return false;
	}

	public static bool IsArray(this ProtodefType type)
	{
		return type is ProtodefArray;
	}

	public static bool IsBuffer(this ProtodefType type)
	{
		return type is ProtodefBuffer;
	}

}